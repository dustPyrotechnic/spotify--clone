# 锁屏进度定时器设计详解

> 文档日期：2026-02-07  
> 涉及文件：XCMusicPlayerModel.m

---

## 一、问题背景

### 1.1 原始问题

iOS 锁屏控制中心的进度条显示需要依赖 `MPNowPlayingInfoCenter` 提供的数据：

```objc
// 总时长
[dict setObject:@(totalDuration) forKey:MPMediaItemPropertyPlaybackDuration];

// 已播放时间
[dict setObject:@(elapsedTime) forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime];

// 播放速率（1.0=正常播放，0.0=暂停）
[dict setObject:@(rate) forKey:MPNowPlayingInfoPropertyPlaybackRate];
```

### 1.2 遇到的问题

**问题1：固定值问题**
```objc
// 原始代码硬编码了 50 秒
[dict setObject:@(50.0) forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime];
```
- 实际刚开始播放时，已播放时间应该是 0
- 50 秒导致进度条直接跳到中间位置

**问题2：不更新的问题**
- 只在歌曲切换时更新一次锁屏信息
- 之后已播放时间不再变化
- 进度条不会随播放自动前进

### 1.3 解决思路

需要一个机制来**定期更新**锁屏的已播放时间，让进度条实时反映播放进度。

---

## 二、定时器设计方案

### 2.1 设计目标

1. **实时性**：每秒更新一次进度条
2. **准确性**：反映 `AVPlayer` 的实际播放时间
3. **状态同步**：播放时更新，暂停时停止
4. **资源管理**：避免内存泄漏和重复定时器

### 2.2 核心机制

```
┌─────────────────────────────────────────────────────────┐
│                      播放状态变化                          │
│                                                         │
│   播放 ───────► 启动定时器 ───────► 每秒更新锁屏进度      │
│    │                                                    │
│    │                                                    │
│   暂停 ───────► 停止定时器 ───────► 更新一次（Rate=0）   │
│    │                                                    │
│    │                                                    │
│   切歌 ───────► 停止旧定时器 ─────► 启动新定时器         │
└─────────────────────────────────────────────────────────┘
```

---

## 三、代码实现详解

### 3.1 定时器属性定义

```objc
@interface XCMusicPlayerModel ()
/// 锁屏进度更新定时器
@property (nonatomic, strong) NSTimer *lockScreenTimer;
@end
```

使用 `strong` 属性保持对定时器的引用，方便后续停止。

### 3.2 启动定时器

```objc
- (void)startLockScreenProgressTimer {
    // 1. 先停止之前的定时器（防止重复）
    [self stopLockScreenProgressTimer];
    
    // 2. 创建新的定时器
    self.lockScreenTimer = [NSTimer scheduledTimerWithTimeInterval:1.0
                                                            target:self
                                                          selector:@selector(updateLockScreenProgress)
                                                          userInfo:nil
                                                           repeats:YES];
    NSLog(@"[PlayerModel] ⏱️ 启动锁屏进度定时器");
}
```

**关键点**：
- **先停止后启动**：防止重复创建定时器导致更新频率异常
- **时间间隔 1.0 秒**：每秒更新一次，既实时又不耗性能
- **repeats:YES**：持续更新直到手动停止

### 3.3 停止定时器

```objc
- (void)stopLockScreenProgressTimer {
    if (self.lockScreenTimer) {
        // invalidate 会停止定时器并解除所有引用
        [self.lockScreenTimer invalidate];
        self.lockScreenTimer = nil;
        NSLog(@"[PlayerModel] ⏱️ 停止锁屏进度定时器");
    }
}
```

**关键点**：
- **必须 invalidate**：否则定时器会继续运行导致内存泄漏
- **置 nil**：防止野指针

### 3.4 定时更新方法

```objc
- (void)updateLockScreenProgress {
    // 1. 安全检查
    if (!self.nowPlayingSong || !self.player) {
        return;
    }
    
    // 2. 获取当前的锁屏信息（增量更新）
    MPNowPlayingInfoCenter *infoCenter = [MPNowPlayingInfoCenter defaultCenter];
    NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithDictionary:infoCenter.nowPlayingInfo];
    
    // 3. 获取 AVPlayer 的实际播放时间
    NSTimeInterval currentTime = CMTimeGetSeconds(self.player.currentTime);
    
    // 4. 处理无效值
    if (isnan(currentTime) || currentTime < 0) {
        currentTime = 0;
    }
    
    // 5. 更新已播放时间
    [dict setObject:@(currentTime) forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime];
    
    // 6. 根据播放器状态设置播放速率
    CGFloat rate = (self.player.rate > 0) ? 1.0 : 0.0;
    [dict setObject:@(rate) forKey:MPNowPlayingInfoPropertyPlaybackRate];
    
    // 7. 提交更新
    [infoCenter setNowPlayingInfo:dict];
}
```

**关键点**：

1. **增量更新**：
   ```objc
   NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithDictionary:infoCenter.nowPlayingInfo];
   ```
   先获取现有信息，只修改时间和速率，保留其他信息（歌名、封面等）

2. **获取实际时间**：
   ```objc
   NSTimeInterval currentTime = CMTimeGetSeconds(self.player.currentTime);
   ```
   从 AVPlayer 获取真实的播放进度

3. **处理无效值**：
   ```objc
   if (isnan(currentTime) || currentTime < 0) {
       currentTime = 0;
   }
   ```
   AVPlayer 在加载过程中可能返回 NaN 或负数，需要保护

4. **同步播放速率**：
   ```objc
   CGFloat rate = (self.player.rate > 0) ? 1.0 : 0.0;
   ```
   锁屏进度条会根据 rate 决定是否自动前进

---

## 四、触发点设计

### 4.1 播放时启动

```objc
- (void)playMusic {
    NSLog(@"[PlayerModel] ▶️ 继续播放");
    [self.player play];
    
    // 启动定时器，开始定期更新锁屏进度
    [self startLockScreenProgressTimer];
    
    // 立即更新一次锁屏信息（设置 Rate=1.0）
    [self updateLockScreenInfo];
}
```

### 4.2 暂停时停止

```objc
- (void)pauseMusic {
    NSLog(@"[PlayerModel] ⏸️ 暂停播放");
    [self.player pause];
    
    // 停止定时器，不再更新进度
    [self stopLockScreenProgressTimer];
    
    // 更新一次锁屏信息（设置 Rate=0.0）
    [self updateLockScreenInfo];
}
```

### 4.3 切换歌曲时重启

```objc
- (void)playWithURL:(NSURL *)url songId:(NSString *)songId {
    // ... 创建/替换播放器 ...
    
    [self.player play];
    
    // 更新完整的锁屏信息（歌名、歌手、封面等）
    [self updateLockScreenInfo];
    
    // 启动定时器更新进度
    [self startLockScreenProgressTimer];
}
```

---

## 五、流程时序图

### 5.1 正常播放流程

```
时间轴 ────────────────────────────────────────────────►

用户点击播放
    │
    ▼
playMusic 被调用
    │
    ├───► [self.player play]
    │
    ├───► [self startLockScreenProgressTimer]
    │           │
    │           ▼
    │       创建 NSTimer（每秒触发）
    │           │
    │           ▼
    │       updateLockScreenProgress（第1秒）
    │       updateLockScreenProgress（第2秒）
    │       updateLockScreenProgress（第3秒）
    │       ...
    │
    └───► [self updateLockScreenInfo]
                │
                ▼
            设置 Rate=1.0
            锁屏进度条开始走动


时间轴 ─────┬─────┬─────┬─────┬─────┬─────┬─────►
           0s    1s    2s    3s    4s    5s
           │     │     │     │     │     │
锁屏进度    0:00  0:01  0:02  0:03  0:04  0:05
```

### 5.2 暂停流程

```
用户点击暂停
    │
    ▼
pauseMusic 被调用
    │
    ├───► [self.player pause]
    │
    ├───► [self stopLockScreenProgressTimer]
    │           │
    │           ▼
    │       [timer invalidate]
    │       timer = nil
    │       不再触发更新
    │
    └───► [self updateLockScreenInfo]
                │
                ▼
            设置 Rate=0.0
            锁屏进度条停止在 0:05
```

### 5.3 恢复播放流程

```
用户点击继续
    │
    ▼
playMusic 被调用（同5.1）
    │
    ├───► [self.player play]
    │
    ├───► [self startLockScreenProgressTimer] 重新启动
    │           │
    │           ▼
    │       从 0:05 继续更新
    │       0:06, 0:07, 0:08...
    │
    └───► [self updateLockScreenInfo]
                │
                ▼
            设置 Rate=1.0
            锁屏进度条继续走动
```

---

## 六、边界情况处理

### 6.1 防止重复定时器

```objc
- (void)startLockScreenProgressTimer {
    // 先停止之前的，再创建新的
    [self stopLockScreenProgressTimer];
    self.lockScreenTimer = ...;
}
```

**场景**：用户连续点击播放按钮，不会创建多个定时器

### 6.2 空值保护

```objc
- (void)updateLockScreenProgress {
    if (!self.nowPlayingSong || !self.player) {
        return;
    }
    // ...
}
```

**场景**：定时器触发时，歌曲已被清空或播放器被释放

### 6.3 无效时间处理

```objc
NSTimeInterval currentTime = CMTimeGetSeconds(self.player.currentTime);
if (isnan(currentTime) || currentTime < 0) {
    currentTime = 0;
}
```

**场景**：歌曲刚开始加载时，AVPlayer 返回 NaN

### 6.4 内存管理

```objc
- (void)dealloc {
    [self stopLockScreenProgressTimer];
}
```

建议在 dealloc 中也停止定时器，虽然单例不会被释放，但这是良好习惯。

---

## 七、性能考量

### 7.1 为什么选择 1 秒间隔？

| 间隔 | 优点 | 缺点 |
|------|------|------|
| 0.1s | 更新非常流畅 | 耗电，过度更新 |
| 0.5s | 较流畅 | 仍然频繁 |
| **1.0s** | **平衡** | **推荐** |
| 2.0s | 省电 | 更新不够及时 |
| 5.0s | 非常省电 | 用户体验差 |

### 7.2 为什么不监听 AVPlayer 的回调？

```objc
// 可以添加 timeObserver，但过于频繁
[self.player addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) 
                                          queue:dispatch_get_main_queue() 
                                     usingBlock:^(CMTime time) {
    // 每秒回调，但这里更新锁屏太频繁
}];
```

定时器方案更轻量，且与播放器解耦。

---

## 八、与其他模块的关系

```
┌─────────────────────────────────────────────────────────┐
│                    XCMusicPlayerModel                    │
│                                                          │
│  ┌──────────────┐      ┌──────────────────────┐         │
│  │   AVPlayer   │      │   MPNowPlayingInfo   │         │
│  │              │      │       Center         │         │
│  │  currentTime │──────│  ElapsedPlaybackTime │◄────────┤
│  │     rate     │      │      PlaybackRate    │         │
│  └──────────────┘      └──────────────────────┘         │
│           │                      ▲                      │
│           │                      │                      │
│           ▼                      │                      │
│  ┌──────────────────┐            │                      │
│  │  lockScreenTimer │────────────┘                      │
│  │   (每秒触发)      │      updateLockScreenProgress    │
│  └──────────────────┘                                   │
│                                                          │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   iOS 锁屏界面   │
                    │   进度条显示     │
                    └─────────────────┘
```

---

## 九、调试技巧

### 9.1 查看定时器状态

```objc
NSLog(@"定时器是否存在: %@", self.lockScreenTimer ? @"是" : @"否");
NSLog(@"定时器是否有效: %@", [self.lockScreenTimer isValid] ? @"是" : @"否");
```

### 9.2 查看锁屏信息

```objc
// 在 updateLockScreenProgress 中添加日志
NSLog(@"更新锁屏进度: %.1f / %.1f 秒, rate=%.1f", 
      currentTime, 
      self.nowPlayingSong.duration / 1000.0,
      rate);
```

### 9.3 验证更新频率

```objc
// 添加时间戳日志
static NSDate *lastUpdate = nil;
NSDate *now = [NSDate date];
if (lastUpdate) {
    NSTimeInterval interval = [now timeIntervalSinceDate:lastUpdate];
    NSLog(@"距离上次更新: %.3f 秒", interval);  // 应该约等于 1.0
}
lastUpdate = now;
```

---

## 十、总结

| 设计要点 | 实现方式 |
|----------|----------|
| 实时更新 | NSTimer 每秒触发 |
| 数据准确 | 从 AVPlayer 获取 currentTime |
| 状态同步 | play启动，pause停止 |
| 资源管理 | invalidate + nil |
| 容错处理 | 空值检查、NaN检查 |
| 性能优化 | 增量更新、1秒间隔 |

这套定时器机制确保了锁屏进度条与实际播放进度保持同步，同时避免了不必要的性能开销。
