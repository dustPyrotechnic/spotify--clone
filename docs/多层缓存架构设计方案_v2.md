# Spotify Clone 多层缓存架构设计方案 V2

> 设计日期：2026-02-08  
> 设计目标：构建完整的 L1/L2/L3 三级缓存体系  
> 兼容性：与现有代码渐进式集成，支持灰度切换

---

## 一、现状分析

### 1.1 现有缓存机制

| 组件 | 现状 | 问题 |
|------|------|------|
| `XCResourceLoaderManager` | 仅实现拦截框架，无实际缓存逻辑 | 音频无法离线播放，每次重复下载 |
| `SDWebImage` | 已集成，自动管理图片缓存 | 未针对音乐App优化缓存策略 |
| `WCDB` | 已集成但未用于音频缓存 | 数据库表结构待设计 |
| API响应 | 无缓存，每次都请求 | 弱网环境体验差，浪费流量 |
| Token | KeyChain存储 | ✅ 已合理 |

### 1.2 核心痛点

```
用户场景痛点:
├── 地铁通勤: 网络不稳定，歌曲播放卡顿
├── 重复收听: 同一首歌每次重新下载
├── 快速切换: Seek后无缓存，等待时间长
├── 列表浏览: 专辑封面重复加载，闪烁
└── 离线场景: 完全无法使用
```

---

## 二、目标架构设计

### 2.1 三级缓存金字塔

```
┌─────────────────────────────────────────────────────────────┐
│                     L1: 内存缓存层                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  图片内存缓存  │  │  音频数据缓冲  │  │  API响应缓存   │      │
│  │ (NSCache)    │  │ (256KB缓冲)  │  │ (LRU字典)    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  特点: 最快访问，容量最小，App退出清空                         │
├─────────────────────────────────────────────────────────────┤
│                     L2: 磁盘缓存层                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  图片磁盘缓存  │  │  音频分段缓存  │  │  API数据持久化 │      │
│  │(SDWebImage)  │  │   (WCDB)     │  │   (WCDB)     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  特点: 持久化存储，支持随机读取，容量中等                      │
├─────────────────────────────────────────────────────────────┤
│                     L3: 网络层                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                  CDN / 源站服务器                      │  │
│  └──────────────────────────────────────────────────────┘  │
│  特点: 最终数据源，最慢但最完整                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 缓存读取流程

```
用户请求数据(图片/音频/API)
         │
         ▼
    ┌─────────────┐
    │  查询L1内存  │◄──────── 最快 (<1ms)
    └──────┬──────┘
           │ 未命中
           ▼
    ┌─────────────┐
    │  查询L2磁盘  │◄──────── 快速 (10-50ms)
    └──────┬──────┘
           │ 未命中
           ▼
    ┌─────────────┐
    │  请求L3网络  │◄──────── 最慢 (100ms-数秒)
    └──────┬──────┘
           │
           ▼
    数据返回给用户
           │
           ▼
    异步写入L2 ← 异步写入L1 (热度提升)
```

---

## 三、分层详细设计

### 3.1 L1 内存缓存层

#### 3.1.1 音频数据缓冲 (XCMemoryAudioBuffer)

```objc
// 职责: 当前播放歌曲的热数据缓冲
@interface XCMemoryAudioBuffer : NSObject

// 循环缓冲区，存储当前播放点附近256KB数据
@property (nonatomic, strong) NSMutableData *ringBuffer;
@property (nonatomic, assign) NSUInteger bufferSize;      // 256KB
@property (nonatomic, assign) NSUInteger currentOffset;   // 当前播放位置

// 核心方法
- (NSData *)dataForRange:(NSRange)range;                 // 查询缓冲区
- (void)fillBufferWithData:(NSData *)data offset:(NSUInteger)offset;
- (void)seekToOffset:(NSUInteger)offset;                 // Seek后重置缓冲区

@end
```

**设计要点:**
- 环形缓冲区避免频繁内存分配
- 只缓存当前播放歌曲，切歌即清空
- 与磁盘缓存配合，优先查内存，未命中查磁盘

#### 3.1.2 API响应缓存 (XCMemoryAPICache)

```objc
// 职责: 缓存API响应，减少重复请求
@interface XCMemoryAPICache : NSObject

// 缓存结构: URL -> (Data, ExpireTime)
@property (nonatomic, strong) NSCache<NSString *, XCCacheEntry *> *cache;

// 缓存策略
@property (nonatomic, assign) NSTimeInterval defaultTTL;  // 默认5分钟
@property (nonatomic, assign) NSUInteger maxEntryCount;   // 最大100条

// 分类缓存时长
- (NSTimeInterval)ttlForEndpoint:(NSString *)endpoint;
// /album/list      -> 10分钟 (专辑列表变化不频繁)
// /top/playlist    -> 5分钟  
// /album?id=xxx    -> 30分钟 (专辑详情基本不变)
// /song/url/v1     -> 不缓存 (URL有时效性)

@end
```

### 3.2 L2 磁盘缓存层

#### 3.2.1 音频分段缓存 (核心)

**数据表设计:**

```sql
-- 音频元数据表
CREATE TABLE AudioMetadata (
    songId              TEXT PRIMARY KEY,   -- 歌曲ID (网易云)
    songName            TEXT,               -- 歌曲名称(用于显示)
    artistName          TEXT,               -- 艺术家名称
    totalSize           INTEGER,            -- 文件总大小(字节)
    duration            INTEGER,            -- 总时长(毫秒)
    bitrate             INTEGER,            -- 比特率
    cachedSize          INTEGER DEFAULT 0,  -- 已缓存大小
    segmentCount        INTEGER DEFAULT 0,  -- 分段数量
    playCount           INTEGER DEFAULT 0,  -- 播放次数(LRU权重)
    lastPlayTime        INTEGER,            -- 最后播放时间戳
    createdAt           INTEGER,            -- 创建时间
    updatedAt           INTEGER,            -- 更新时间
    isFullyCached       BOOLEAN DEFAULT 0,  -- 是否完整缓存
    
    -- 索引
    INDEX idx_lastPlay (lastPlayTime),
    INDEX idx_playCount (playCount)
);

-- 音频分段数据表
CREATE TABLE AudioSegment (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    songId      TEXT NOT NULL,
    startOffset INTEGER NOT NULL,       -- 分段起始位置
    endOffset   INTEGER NOT NULL,       -- 分段结束位置
    data        BLOB NOT NULL,          -- 音频数据(256KB)
    
    -- 约束
    UNIQUE(songId, startOffset),
    FOREIGN KEY (songId) REFERENCES AudioMetadata(songId) ON DELETE CASCADE
    
    -- 索引
    INDEX idx_song_range (songId, startOffset, endOffset)
);

-- 缓存统计表(用于清理决策)
CREATE TABLE CacheStatistics (
    id                  INTEGER PRIMARY KEY,
    totalCacheSize      INTEGER DEFAULT 0,  -- 总缓存大小
    totalSongs          INTEGER DEFAULT 0,  -- 总歌曲数
    lastCleanupTime     INTEGER             -- 最后清理时间
);
```

**分段策略:**

```
┌──────────────────────────────────────────────────────────────┐
│  歌曲文件: 5MB (约4分钟音频)                                    │
├──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┤
│ 256KB│ 256KB│ 256KB│ 256KB│ 256KB│ 256KB│ 256KB│ 256KB│ 256KB│ ...
│  #0  │  #1  │  #2  │  #3  │  #4  │  #5  │  #6  │  #7  │  #8  │
├──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤
│                                                              │
│  用户播放到 01:30 (约1.4MB位置)                                │
│              ▼                                               │
│  缓存命中: Segment #0, #1, #2, #3, #4, #5 (部分)              │
│  需要下载: Segment #5 (剩余部分), #6, #7...                    │
│                                                              │
│  用户Seek到 03:00 (约2.8MB位置)                               │
│                          ▼                                   │
│  缓存命中: Segment #0~#10                                     │
│  即时响应: ✅ 无需网络请求                                      │
└──────────────────────────────────────────────────────────────┘
```

**核心管理类:**

```objc
// XCAudioCacheManager.h
@interface XCAudioCacheManager : NSObject

+ (instancetype)sharedInstance;

#pragma mark - 元数据管理
- (void)saveMetadata:(XCAudioMetadata *)metadata;
- (XCAudioMetadata *)metadataForSongId:(NSString *)songId;
- (void)updatePlayStatisticsForSongId:(NSString *)songId;

#pragma mark - 分段数据管理
- (void)saveSegment:(NSData *)data 
           forRange:(NSRange)range 
         withSongId:(NSString *)songId;

- (NSData *)segmentForRange:(NSRange)range 
                 withSongId:(NSString *)songId;

- (NSArray<XCCachedRange *> *)cachedRangesForSongId:(NSString *)songId;

#pragma mark - 缓存查询
- (XCCacheHitType)checkCacheForSongId:(NSString *)songId 
                                range:(NSRange)range;
// XCCacheHitTypeFull    - 完全命中
// XCCacheHitTypePartial - 部分命中，返回已缓存区间
// XCCacheHitTypeNone    - 未命中

#pragma mark - 缓存清理
- (void)cleanupWithPolicy:(XCCacheCleanupPolicy)policy;
- (void)removeCacheForSongId:(NSString *)songId;
- (void)removeAllCache;

@end
```

#### 3.2.2 API数据持久化

```objc
// XCAPIPersistentCache.h
// 缓存API响应，支持离线浏览

@interface XCAPIPersistentCache : NSObject

+ (instancetype)sharedInstance;

// 存储API响应
- (void)cacheResponse:(id)responseObject 
              forURL:(NSString *)urlString 
               withTTL:(NSTimeInterval)ttl;

// 获取缓存(如果未过期)
- (id)cachedResponseForURL:(NSString *)urlString;

// 清除过期缓存
- (void)removeExpiredCache;

@end
```

**缓存数据表:**

```sql
CREATE TABLE APIResponseCache (
    url         TEXT PRIMARY KEY,
    responseData BLOB NOT NULL,
    contentType TEXT,
    createdAt   INTEGER,
    expiresAt   INTEGER,
    etag        TEXT  -- 用于条件请求
);

CREATE INDEX idx_expires ON APIResponseCache(expiresAt);
```

### 3.3 ResourceLoader 拦截器实现

#### 3.3.1 架构图

```
AVPlayer请求
     │
     ▼
┌─────────────────────────────────────────────────────────────┐
│           XCAudioResourceLoader (AVAssetResourceLoaderDelegate)│
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. URL转换:                                                │
│     https://music.163.com/xxx.mp3                           │
│         ↓                                                   │
│     custom://audio/songId@originalHost/path                 │
│                                                             │
│  2. 拦截到请求后:                                            │
│     ┌─────────────────────────────────────────────────┐    │
│     │           XCAudioCachePipeline                   │    │
│     ├─────────────────────────────────────────────────┤    │
│     │                                                 │    │
│     │  ① 解析请求范围(requestedOffset, requestedLength) │    │
│     │                                                 │    │
│     │  ② 查询缓存状态                                  │    │
│     │     ├── L1内存缓冲? 返回数据                     │    │
│     │     └── 未命中 → 查询L2磁盘缓存                  │    │
│     │                                                 │    │
│     │  ③ L2查询结果:                                   │    │
│     │     ├── 完全命中 → 返回数据 + 填充L1              │    │
│     │     ├── 部分命中 → 返回部分 + 下载缺失部分        │    │
│     │     └── 未命中   → 发起Range请求                 │    │
│     │                                                 │    │
│     │  ④ 网络下载:                                     │    │
│     │     发起HTTP Range请求                           │    │
│     │     边下载边返回给AVPlayer                       │    │
│     │     异步存入L2磁盘缓存                           │    │
│     │                                                 │    │
│     └─────────────────────────────────────────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 3.3.2 核心实现类

```objc
// XCAudioResourceLoader.h
@interface XCAudioResourceLoader : NSObject <AVAssetResourceLoaderDelegate>

+ (instancetype)sharedInstance;

// 将原始URL转换为Custom URL以触发拦截
- (NSURL *)customURLForOriginalURL:(NSURL *)originalURL songId:(NSString *)songId;

// 预加载(后台下载歌曲开头数据)
- (void)preloadAudioForSongId:(NSString *)songId 
                          url:(NSURL *)url 
                       length:(NSUInteger)bytes;

@end
```

```objc
// XCAudioCachePipeline.h
// 处理单个数据请求的核心管道

@interface XCAudioCachePipeline : NSObject

- (instancetype)initWithLoadingRequest:(AVAssetResourceLoadingRequest *)request
                                songId:(NSString *)songId;

// 启动处理流程
- (void)start;

// 取消处理
- (void)cancel;

@end
```

#### 3.3.3 处理流程详解

```objc
// 伪代码展示核心逻辑
- (void)handleLoadingRequest:(AVAssetResourceLoadingRequest *)request {
    NSRange requestedRange = [self parseRangeFromRequest:request];
    
    // 1. 查询缓存
    XCCacheQueryResult *result = [self.cacheManager queryCacheForSongId:songId 
                                                                  range:requestedRange];
    
    switch (result.type) {
        case XCCacheHitTypeFull:
            // 完全命中: 直接返回
            [request respondWithData:result.data];
            [request finishLoading];
            break;
            
        case XCCacheHitTypePartial: {
            // 部分命中: 返回已有部分，下载缺失部分
            NSArray<NSValue *> *missingRanges = result.missingRanges;
            
            // 先返回已缓存的部分
            for (XCCachedRange *cached in result.cachedRanges) {
                NSData *data = [self.cacheManager segmentForRange:cached.range 
                                                       withSongId:songId];
                [request respondWithData:data];
            }
            
            // 下载缺失的部分
            for (NSValue *rangeValue in missingRanges) {
                NSRange missingRange = [rangeValue rangeValue];
                [self downloadRange:missingRange completion:^(NSData *data) {
                    // 存入缓存
                    [self.cacheManager saveSegment:data 
                                          forRange:missingRange 
                                        withSongId:songId];
                    // 返回给播放器
                    [request respondWithData:data];
                }];
            }
            break;
        }
            
        case XCCacheHitTypeNone:
            // 未命中: 发起Range请求
            [self downloadRange:requestedRange completion:^(NSData *data) {
                [self.cacheManager saveSegment:data 
                                      forRange:requestedRange 
                                    withSongId:songId];
                [request respondWithData:data];
                [request finishLoading];
            }];
            break;
    }
}
```

---

## 四、缓存清理策略

### 4.1 多级清理触发条件

```
触发条件:
┌──────────────────────────────────────────────────────────────┐
│ 1. 定时清理                                                   │
│    - App进入后台时                                            │
│    - 每隔24小时(首次启动时检查)                                │
├──────────────────────────────────────────────────────────────┤
│ 2. 容量阈值清理                                               │
│    - 音频缓存 > 500MB                                         │
│    - API缓存 > 50MB                                           │
│    - 磁盘空间 < 500MB (系统告警)                               │
├──────────────────────────────────────────────────────────────┤
│ 3. 手动清理                                                   │
│    - 用户点击"清除缓存"按钮                                    │
│    - 设置中提供清理选项                                        │
└──────────────────────────────────────────────────────────────────┘
```

### 4.2 LRU+热度加权清理算法

```objc
// 清理优先级算法
- (NSArray<NSString *> *)songsToRemoveWithLimit:(NSUInteger)byteLimit {
    NSMutableArray<XCAudioMetadata *> *candidates = [self allMetadata];
    
    // 计算每个歌曲的权重分数(越低越优先删除)
    for (XCAudioMetadata *meta in candidates) {
        // 分数 = 最后播放时间权重 + 播放次数权重 + 是否完整缓存权重
        NSTimeInterval daysSinceLastPlay = (now - meta.lastPlayTime) / 86400.0;
        
        CGFloat timeScore = daysSinceLastPlay * 10;           // 越久分越高
        CGFloat countScore = -meta.playCount * 5;              // 越多分越低(保护)
        CGFloat completeScore = meta.isFullyCached ? -20 : 0;  // 完整缓存保护
        CGFloat sizeScore = meta.cachedSize / (1024.0 * 1024.0); // 越大分越高(优先删大文件)
        
        meta.priorityScore = timeScore + countScore + completeScore + sizeScore;
    }
    
    // 按分数排序(低到高，即优先删除到低分)
    [candidates sortUsingComparator:^NSComparisonResult(XCAudioMetadata *a, 
                                                        XCAudioMetadata *b) {
        return [@(a.priorityScore) compare:@(b.priorityScore)];
    }];
    
    // 累加删除直到满足容量要求
    NSMutableArray<NSString *> *toRemove = [NSMutableArray array];
    NSUInteger accumulatedSize = 0;
    
    for (XCAudioMetadata *meta in candidates) {
        if (accumulatedSize >= byteLimit) break;
        
        // 保留规则:
        // 1. 播放次数 > 10 的歌曲不删
        if (meta.playCount > 10) continue;
        
        // 2. 最近7天内播放过的歌曲不删
        if ((now - meta.lastPlayTime) < 7 * 86400) continue;
        
        [toRemove addObject:meta.songId];
        accumulatedSize += meta.cachedSize;
    }
    
    return toRemove;
}
```

### 4.3 清理策略配置

```objc
@interface XCCachePolicy : NSObject

// 容量限制
@property (nonatomic, assign) NSUInteger maxAudioCacheSize;    // 默认 500MB
@property (nonatomic, assign) NSUInteger maxAPICacheSize;      // 默认 50MB
@property (nonatomic, assign) NSUInteger minFreeDiskSpace;     // 默认 500MB

// 时间策略
@property (nonatomic, assign) NSTimeInterval maxCacheAge;      // 默认 30天
@property (nonatomic, assign) NSTimeInterval unusedThreshold;  // 默认 7天

// 保护策略
@property (nonatomic, assign) NSUInteger minPlayCountToKeep;   // 默认 10次
@property (nonatomic, assign) BOOL keepFullyCachedSongs;       // 默认 YES

@end
```

---

## 五、与现有代码集成方案

### 5.1 渐进式升级策略

```
Phase 1: 基础设施 (Week 1)
├─ 创建 XCCacheManager 基础框架
├─ WCDB 表结构创建
└─ 与现有代码零耦合

Phase 2: 音频缓存 (Week 2-3)
├─ 完善 XCResourceLoaderManager
├─ 实现分段缓存逻辑
├─ 集成到 XCMusicPlayerModel (通过分类扩展)
└─ 添加功能开关: XCConfig.enableAudioCache

Phase 3: API缓存 (Week 4)
├─ 包装 XCNetworkManager
├─ 添加响应缓存逻辑
└─ 针对首页/专辑详情等高优先级接口

Phase 4: 清理策略 (Week 5)
├─ 实现 LRU 清理
├─ 添加设置界面缓存管理
└─ 性能调优与监控
```

### 5.2 代码集成示例

```objc
// XCMusicPlayerModel+AudioCache.h
// 通过分类扩展现有播放器，零侵入

@interface XCMusicPlayerModel (AudioCache)

// 启用缓存后，自动转换URL
- (void)playSongWithCache:(XC_YYSongData *)song;

// 预加载下一首
- (void)preloadNextSong:(XC_YYSongData *)song;

@end
```

```objc
// 实现示例
@implementation XCMusicPlayerModel (AudioCache)

- (void)playSongWithCache:(XC_YYSongData *)song {
    if (!XCConfig.enableAudioCache) {
        // 回退到原有逻辑
        [self playSong:song];
        return;
    }
    
    // 1. 获取原始URL
    [[XCNetworkManager sharedInstance] findUrlOfSongWithId:song.songId 
                                                  completion:^(NSURL *url) {
        if (!url) return;
        
        // 2. 转换为Custom URL
        NSURL *customURL = [[XCAudioResourceLoader sharedInstance] 
                            customURLForOriginalURL:url 
                            songId:song.songId];
        
        // 3. 使用Custom URL创建AVPlayerItem
        AVPlayerItem *item = [AVPlayerItem playerItemWithURL:customURL];
        
        // 4. 设置ResourceLoaderDelegate
        [item.resourceLoader setDelegate:[XCAudioResourceLoader sharedInstance] 
                                   queue:dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)];
        
        // 5. 播放
        [self.player replaceCurrentItemWithPlayerItem:item];
        [self.player play];
        
        // 6. 更新统计
        [[XCAudioCacheManager sharedInstance] updatePlayStatisticsForSongId:song.songId];
    }];
}

@end
```

### 5.3 配置管理

```objc
// XCConfig.h
@interface XCConfig : NSObject

// 功能开关
+ (BOOL)enableAudioCache;      // 默认 YES
+ (BOOL)enableAPICache;        // 默认 YES
+ (BOOL)enableMemoryBuffer;    // 默认 YES

// 缓存限制
+ (NSUInteger)maxAudioCacheSize;
+ (NSUInteger)maxAPICacheSize;

// 调试选项
+ (BOOL)cacheDebugMode;        // 输出详细日志

@end
```

---

## 六、性能指标与监控

### 6.1 关键指标

| 指标 | 目标值 | 测量方式 |
|------|--------|----------|
| 音频缓存命中率 | > 60% | 命中次数/总请求次数 |
| API缓存命中率 | > 40% | 命中次数/总请求次数 |
| 平均Seek响应时间 | < 100ms | 从Seek到开始播放 |
| 缓存写入速度 | > 1MB/s | 持续下载时的写入性能 |
| 磁盘空间占用 | < 500MB | 定期清理后 |

### 6.2 调试工具

```objc
// XCCacheDebugger.h
@interface XCCacheDebugger : NSObject

// 输出缓存统计
+ (void)printCacheStatistics;

// 输出示例:
// ========== 缓存统计 ==========
// 音频缓存:
//   - 总歌曲数: 45
//   - 总大小: 320MB
//   - 完全缓存: 12
//   - 命中率: 65%
// API缓存:
//   - 条目数: 128
//   - 总大小: 2.3MB
//   - 命中率: 42%
// =============================

// 导出缓存详情到文件(用于分析)
+ (void)exportCacheReportToPath:(NSString *)path;

@end
```

---

## 七、风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| WCDB操作阻塞主线程 | 卡顿 | 所有DB操作放后台队列，异步回调 |
| 缓存文件损坏 | 播放失败 | 定期校验，损坏时自动清理重下 |
| 服务器不支持Range | 无法分段下载 | 检测后回退到完整下载模式 |
| 磁盘空间不足 | 写入失败 | 监控空间，<500MB时暂停缓存 |
| 缓存策略过于激进 | 用户流量浪费 | 默认仅WiFi下自动缓存，蜂窝网络需确认 |
| 与现有逻辑冲突 | 功能异常 | 功能开关，灰度发布，可快速回退 |

---

## 八、总结

### 8.1 核心改进

1. **三级缓存体系**: L1内存 + L2磁盘 + L3网络，层层加速
2. **音频分段缓存**: 256KB分段，支持Seek，节省空间
3. **智能清理策略**: LRU+热度加权，自动管理缓存生命周期
4. **零侵入集成**: 分类扩展+功能开关，渐进式升级

### 8.2 预期效果

| 场景 | 优化前 | 优化后 |
|------|--------|--------|
| 重复播放歌曲 | 每次都下载 | 命中磁盘缓存，即时播放 |
| Seek到已播放位置 | 重新下载 | 命中缓存，即时响应 |
| 弱网环境浏览 | 频繁加载中 | API缓存提升体验 |
| 离线场景 | 完全不可用 | 已缓存歌曲可播放 |

### 8.3 实施建议

1. **先做MVP**: 优先实现基础的分段缓存和ResourceLoader拦截
2. **灰度测试**: 内部测试2周，收集命中率数据
3. **逐步放开**: 先给核心用户使用，稳定后全量
4. **监控埋点**: 关键指标上报，持续优化

---

> 文档版本: 2.0  
> 设计日期: 2026-02-08  
> 作者: AI Assistant  
> 备注: 此方案为设计文档，实际实现需根据测试结果调整参数
