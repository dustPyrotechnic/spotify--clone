# 进度条拖动与分段播放实施计划

> 文档状态：待实施  
> 创建日期：2026-02-20  
> 相关文档：进度调整交互设计方案.md、AudioCacheImplementationPlan.md

---

## 一、现状分析

### 1.1 已完成的基础

| 组件 | 状态 | 说明 |
|------|------|------|
| L1 分段缓存 (NSCache) | ✅ 完整 | `XCMemoryCacheManager` 实现分段存储/读取/合并 |
| L2 临时缓存 | ✅ 完整 | `XCTempCacheManager` 实现临时文件管理 |
| L3 永久缓存 | ✅ 完整 | `XCPersistentCacheManager` + `XCCacheIndexManager` |
| 三级缓存整合 | ✅ 完整 | `XCAudioCacheManager` 统一入口 |
| 预加载机制 | ✅ 完整 | `XCPreloadManager` 实现 50% 触发预加载 |
| 播放器集成 | ✅ 完整 | `XCMusicPlayerModel` 已集成缓存查询 |

### 1.2 缺失的功能

| 功能 | 状态 | 影响 |
|------|------|------|
| **进度条拖动播放** | ❌ 未实现 | 用户无法跳转到指定时间 |
| **资源加载器实现** | ⚠️ 空壳 | `XCResourceLoaderManager` 仅打印日志 |
| **分段播放 (边下边播)** | ❌ 未实现 | 播放器无法利用分段缓存 |

---

## 二、目标

### 2.1 短期目标（Phase A）
实现 **进度条拖动播放** 功能
- App 内 UISlider 拖动跳转
- 锁屏进度控制
- "暂停-调整-恢复" 交互流程

### 2.2 中期目标（Phase B）
实现 **真正的分段播放/边下边播**
- 完善 `XCResourceLoaderManager`
- 解析播放器 Range 请求
- 优先从 L1 分段缓存响应
- 未命中时网络请求并写入 L1

---

## 三、Phase A: 进度条拖动播放 ✅ 已完成

### 3.1 涉及文件

```
Spotify - clone/
├── 5. TabBar附加视图，搜索部分/1. 音乐播放器/音乐播放详细页面/
│   ├── XCMusicPlayerViewController.m   [修改] 添加滑块事件处理
│   └── XCMusicPlayerModel.m            [修改] 完善锁屏进度控制
```

### 3.2 任务清单

#### 任务 A1: 添加 UISlider 事件监听
**文件**: `XCMusicPlayerViewController.m`

```objc
- (void)viewDidLoad {
    // ... 现有代码 ...
    
    // 添加滑块事件监听
    [self.mainView.mainSlider addTarget:self 
                                 action:@selector(sliderTouchDown:) 
                       forControlEvents:UIControlEventTouchDown];
    
    [self.mainView.mainSlider addTarget:self 
                                 action:@selector(sliderValueChanged:) 
                       forControlEvents:UIControlEventValueChanged];
    
    [self.mainView.mainSlider addTarget:self 
                                 action:@selector(sliderTouchUp:) 
                       forControlEvents:UIControlEventTouchUpInside | UIControlEventTouchUpOutside];
}
```

#### 任务 A2: 实现滑块事件处理方法
**文件**: `XCMusicPlayerViewController.m`

```objc
@interface XCMusicPlayerViewController ()
@property (nonatomic, assign) BOOL wasPlayingBeforeSeek;  // 调整前是否播放中
@property (nonatomic, assign) BOOL isSeeking;             // 是否正在调整
@end

// TouchDown - 暂停并记录状态
- (void)sliderTouchDown:(UISlider *)slider {
    NSLog(@"[PlayerVC] 用户开始拖动进度条");
    
    self.isSeeking = YES;
    self.wasPlayingBeforeSeek = self.musicPlayerModel.player.rate > 0;
    
    if (self.wasPlayingBeforeSeek) {
        [self.musicPlayerModel pauseMusic];
    }
    [self.musicPlayerModel stopLockScreenProgressTimer];
}

// ValueChanged - 更新显示
- (void)sliderValueChanged:(UISlider *)slider {
    CGFloat progress = slider.value;  // 0.0 ~ 1.0
    NSTimeInterval totalDuration = self.musicPlayerModel.nowPlayingSong.duration / 1000.0;
    NSTimeInterval targetTime = progress * totalDuration;
    
    // 可更新 UI 时间显示（如有时间标签）
    NSLog(@"[PlayerVC] 拖动中: %.1fs", targetTime);
}

// TouchUp - 执行跳转并恢复
- (void)sliderTouchUp:(UISlider *)slider {
    NSLog(@"[PlayerVC] 用户松开进度条");
    
    CGFloat progress = slider.value;
    NSTimeInterval totalDuration = self.musicPlayerModel.nowPlayingSong.duration / 1000.0;
    NSTimeInterval targetTime = progress * totalDuration;
    
    [self seekToTime:targetTime];
    
    if (self.wasPlayingBeforeSeek) {
        [self.musicPlayerModel playMusic];
    }
    self.isSeeking = NO;
}

// 跳转到指定时间
- (void)seekToTime:(NSTimeInterval)time {
    CMTime targetCMTime = CMTimeMakeWithSeconds(time, NSEC_PER_SEC);
    
    [self.musicPlayerModel.player seekToTime:targetCMTime 
                           completionHandler:^(BOOL finished) {
        if (finished) {
            NSLog(@"[PlayerVC] 跳转完成: %.1fs", time);
            [self.musicPlayerModel updateLockScreenInfo];
        }
    }];
}
```

#### 任务 A3: 完善锁屏进度控制
**文件**: `XCMusicPlayerModel.m` - `setupRemoteCommands` 方法

```objc
[commandCenter.changePlaybackPositionCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) {
    MPChangePlaybackPositionCommandEvent *positionEvent = (MPChangePlaybackPositionCommandEvent *)event;
    NSTimeInterval targetTime = positionEvent.positionTime;
    
    NSLog(@"[PlayerModel] 锁屏进度调整: %.1fs", targetTime);
    
    // 记录状态
    BOOL wasPlaying = self.player.rate > 0;
    if (wasPlaying) {
        [self pauseMusic];
    }
    
    // 执行跳转
    CMTime targetCMTime = CMTimeMakeWithSeconds(targetTime, NSEC_PER_SEC);
    __weak typeof(self) weakSelf = self;
    [self.player seekToTime:targetCMTime completionHandler:^(BOOL finished) {
        if (finished && wasPlaying) {
            [weakSelf playMusic];
        }
    }];
    
    return MPRemoteCommandHandlerStatusSuccess;
}];
```

#### 任务 A4: 添加定时器更新滑块位置
**文件**: `XCMusicPlayerViewController.m`

需要在播放时定时更新 `mainSlider.value` 以反映当前进度：

```objc
// 添加属性
@property (nonatomic, strong) NSTimer *progressTimer;

// 开始更新滑块
- (void)startProgressTimer {
    [self stopProgressTimer];
    self.progressTimer = [NSTimer scheduledTimerWithTimeInterval:0.5
                                                          target:self
                                                        selector:@selector(updateSliderProgress)
                                                        userInfo:nil
                                                         repeats:YES];
}

// 停止更新
- (void)stopProgressTimer {
    if (self.progressTimer) {
        [self.progressTimer invalidate];
        self.progressTimer = nil;
    }
}

// 更新滑块位置
- (void)updateSliderProgress {
    if (self.isSeeking) return;  // 拖动中不更新
    
    NSTimeInterval currentTime = CMTimeGetSeconds(self.musicPlayerModel.player.currentTime);
    NSTimeInterval duration = self.musicPlayerModel.nowPlayingSong.duration / 1000.0;
    
    if (duration > 0) {
        self.mainView.mainSlider.value = currentTime / duration;
    }
}
```

### 3.3 Phase A 实施说明

**实施日期**: 2026-02-20  
**修改文件**:
1. `XCMusicPlayerViewController.m` - 添加滑块事件处理和进度定时器
2. `XCMusicPlayerModel.m` - 完善锁屏进度控制

**实现的功能**:
- ✅ UISlider TouchDown 时暂停音乐并记录状态
- ✅ 拖动时实时计算并显示目标时间
- ✅ TouchUp 时执行 seekToTime 跳转
- ✅ 如果拖动前正在播放，跳转后自动恢复播放
- ✅ 添加 0.5 秒定时器自动更新滑块位置
- ✅ 锁屏界面 changePlaybackPositionCommand 完善实现
- ✅ 添加触感反馈（轻触震动）

### 3.4 Phase A 验证清单

- [x] 触摸滑块时音乐暂停
- [x] 拖动时控制台打印目标时间
- [x] 松开滑块后跳转到对应时间
- [x] 如果之前在播放，跳转后继续播放
- [x] 锁屏界面拖动进度条可跳转
- [x] 滑块位置随播放进度自动更新

---

## 四、Phase B: 分段播放/边下边播 ✅ 已完成

### 4.1 背景说明

当前 `XCResourceLoaderManager` 虽然是 `AVAssetResourceLoaderDelegate`，但只返回 YES 而未实际处理请求：

```objc
// 当前实现（空壳）
- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader 
    shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest {
    NSLog(@"拦截请求: %@", loadingRequest.request.URL);
    return YES;  // 只返回 YES，没有实际处理！
}
```

要实现真正的边下边播，需要：
1. 解析播放器请求的 Range（offset、length）
2. 查询 L1 缓存是否命中
3. 命中：直接返回缓存数据
4. 未命中：网络请求对应分段，同时写入 L1

### 4.2 涉及文件

```
Spotify - clone/
├── 9. 拦截缓存管理/
│   ├── XCResourceLoaderManager.h       [可能扩展]
│   └── XCResourceLoaderManager.m       [重写]
```

### 4.3 任务清单

#### 任务 B1: 实现 Range 请求解析

```objc
@interface XCResourceLoaderManager ()
@property (nonatomic, strong) NSMutableDictionary<NSString *, XCResourceLoadingTask *> *loadingTasks;
@end

// 解析 Range 请求
- (NSRange)parseRangeFromRequest:(NSURLRequest *)request {
    NSString *rangeHeader = request.allHTTPHeaderFields[@"Range"];
    if (!rangeHeader) {
        return NSMakeRange(0, NSUIntegerMax);  // 请求全部
    }
    
    // 解析 "bytes=0-524287" 格式
    NSScanner *scanner = [NSScanner scannerWithString:rangeHeader];
    [scanner scanString:@"bytes=" intoString:nil];
    
    NSInteger start = 0, end = 0;
    [scanner scanInteger:&start];
    [scanner scanString:@"-" intoString:nil];
    [scanner scanInteger:&end];
    
    if (end == 0) {
        return NSMakeRange(start, NSUIntegerMax);
    }
    return NSMakeRange(start, end - start + 1);
}
```

#### 任务 B2: 查询 L1 分段缓存

```objc
// 根据 Range 查询 L1 缓存
- (NSData *)dataFromL1CacheForSongId:(NSString *)songId range:(NSRange)range {
    XCMemoryCacheManager *l1 = [XCMemoryCacheManager sharedInstance];
    
    NSInteger segmentSize = kAudioSegmentSize;  // 512KB
    NSInteger startSegment = range.location / segmentSize;
    NSInteger endSegment = (range.location + range.length - 1) / segmentSize;
    
    NSMutableData *result = [NSMutableData data];
    
    for (NSInteger i = startSegment; i <= endSegment; i++) {
        NSData *segmentData = [l1 segmentDataForSongId:songId segmentIndex:i];
        if (!segmentData) {
            return nil;  // 有分段缺失
        }
        [result appendData:segmentData];
    }
    
    // 截取精确范围
    NSInteger offsetInFirstSegment = range.location % segmentSize;
    if (offsetInFirstSegment > 0 || result.length > range.length) {
        NSRange exactRange = NSMakeRange(offsetInFirstSegment, 
                                         MIN(range.length, result.length - offsetInFirstSegment));
        return [result subdataWithRange:exactRange];
    }
    
    return result;
}
```

#### 任务 B3: 完善 ResourceLoaderDelegate

```objc
#pragma mark - AVAssetResourceLoaderDelegate

- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader 
shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    NSURL *url = loadingRequest.request.URL;
    NSString *songId = [self songIdFromURL:url];
    NSRange range = [self parseRangeFromRequest:loadingRequest.request];
    
    NSLog(@"[ResourceLoader] 请求: %@, Range: %@", songId, NSStringFromRange(range));
    
    // 1. 优先查询 L1 缓存
    NSData *cachedData = [self dataFromL1CacheForSongId:songId range:range];
    if (cachedData) {
        NSLog(@"[ResourceLoader] L1 缓存命中");
        [self respondToLoadingRequest:loadingRequest withData:cachedData];
        return YES;
    }
    
    // 2. 查询 L3 完整缓存
    NSURL *l3URL = [[XCPersistentCacheManager sharedInstance] cachedURLForSongId:songId];
    if (l3URL) {
        NSLog(@"[ResourceLoader] L3 缓存命中");
        [self loadFromLocalFile:l3URL range:range forRequest:loadingRequest];
        return YES;
    }
    
    // 3. 发起网络请求，边下边播
    NSLog(@"[ResourceLoader] 缓存未命中，网络请求");
    [self loadFromNetwork:songId range:range forRequest:loadingRequest];
    
    return YES;
}

- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader 
didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
    // 取消对应的网络任务
    [self cancelLoadingForRequest:loadingRequest];
}
```

#### 任务 B4: 网络请求并写入 L1

```objc
- (void)loadFromNetwork:(NSString *)songId 
                  range:(NSRange)range 
             forRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    // 计算需要下载的分段
    NSInteger segmentSize = kAudioSegmentSize;
    NSInteger startSegment = range.location / segmentSize;
    NSInteger endSegment = (range.location + range.length - 1) / segmentSize;
    
    // 获取网络 URL
    XCNetworkManager *networkManager = [XCNetworkManager sharedInstance];
    [networkManager findUrlOfSongWithId:songId completion:^(NSURL * _Nullable songUrl) {
        if (!songUrl) {
            [loadingRequest finishLoadingWithError:[NSError errorWithDomain:@"ResourceLoader" 
                                                                       code:-1 
                                                                   userInfo:nil]];
            return;
        }
        
        // 创建下载任务，使用 Range 请求
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:songUrl];
        NSString *rangeHeader = [NSString stringWithFormat:@"bytes=%lu-%lu", 
                                (unsigned long)range.location, 
                                (unsigned long)(range.location + range.length - 1)];
        [request setValue:rangeHeader forHTTPHeaderField:@"Range"];
        
        NSURLSessionDataTask *task = [[NSURLSession sharedSession] 
            dataTaskWithRequest:request 
              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
            
            if (error) {
                [loadingRequest finishLoadingWithError:error];
                return;
            }
            
            // 写入 L1 缓存（按分段存储）
            [self storeDataToL1:data songId:songId startSegment:startSegment];
            
            // 响应播放器请求
            [self respondToLoadingRequest:loadingRequest withData:data];
        }];
        
        [task resume];
        
        // 保存任务以便取消
        [self.loadingTasks setObject:task forKey:@(loadingRequest.hash)];
    }];
}

// 将下载的数据按分段存入 L1
- (void)storeDataToL1:(NSData *)data songId:(NSString *)songId startSegment:(NSInteger)startSegment {
    NSInteger segmentSize = kAudioSegmentSize;
    NSInteger offset = 0;
    NSInteger segmentIndex = startSegment;
    
    while (offset < data.length) {
        NSInteger remaining = data.length - offset;
        NSInteger chunkSize = MIN(segmentSize, remaining);
        
        NSData *segmentData = [data subdataWithRange:NSMakeRange(offset, chunkSize)];
        [[XCMemoryCacheManager sharedInstance] storeSegmentData:segmentData 
                                                      forSongId:songId 
                                                   segmentIndex:segmentIndex];
        
        offset += chunkSize;
        segmentIndex++;
    }
}
```

### 4.4 Phase B 实施说明

**实施日期**: 2026-02-20  
**修改文件**:
1. `XCResourceLoaderManager.h/m` - 重写实现完整的资源加载逻辑
2. `XCMusicPlayerModel.m` - 修改 `playWithURL:songId:` 使用自定义 scheme

**实现的功能**:
- ✅ 自定义 scheme URL 转换 (`streaming://songId?url=encodedURL`)
- ✅ Range 请求解析 (bytes=start-end)
- ✅ L1 分段缓存查询（按 512KB 分段组装）
- ✅ L3 完整缓存查询（小文件直接返回）
- ✅ 网络 Range 请求（未命中时）
- ✅ 网络数据写入 L1 分段缓存
- ✅ AVAssetResourceLoaderDelegate 完整实现
- ✅ 任务管理（支持取消）

### 4.5 Phase B 验证清单

- [x] 播放器发起的 Range 请求被正确解析
- [x] L1 有缓存时，直接返回缓存数据（无网络请求）
- [x] L1 无缓存时，发起网络 Range 请求
- [x] 网络数据返回后写入 L1 分段
- [x] 拖动进度条到未缓存位置时，能快速加载
- [x] 切歌时 L1 分段正确合并到 L2/L3

---

## 五、实施状态总结

### ✅ Phase A: 进度条拖动播放（已完成）
- 用户感知最明显的交互功能
- 代码量小，风险低
- UISlider 拖动跳转实现
- 锁屏进度控制完善

### ✅ Phase B: 分段播放（已完成）
- 技术复杂度高，现已实现
- 边下边播功能完整
- L1 分段缓存充分利用
- 拖动进度条时快速响应

**实施日期**: 2026-02-20  
**所有功能已全部完成并集成到播放器中**

---

## 六、风险与注意事项

### 6.1 进度条拖动风险
| 风险 | 应对措施 |
|------|----------|
| 快速多次拖动导致 seek 冲突 | 使用 `isSeeking` 标志位，新的 TouchDown 取消之前的 seek |
| seek 完成后播放状态错乱 | 严格记录 `wasPlayingBeforeSeek` |
| 锁屏与 UI 进度不同步 | 统一通过 `updateLockScreenInfo` 更新 |

### 6.2 分段播放风险
| 风险 | 应对措施 |
|------|----------|
| 分段边界计算错误导致杂音 | 严格使用 512KB 对齐，Range 计算仔细验证 |
| L1 内存占用过大 | 依赖现有的 L1 100MB 上限和 LRU 清理 |
| 网络 Range 请求 416 错误 | 正确处理文件大小边界 |
| 多请求并发冲突 | 使用字典管理 loadingTasks |

---

## 七、相关文档索引

| 文档 | 说明 |
|------|------|
| `进度调整交互设计方案.md` | 详细的状态机设计和代码示例 |
| `AudioCacheImplementationPlan.md` | 缓存架构详细设计 |
| `AGENTS.md` | 项目整体架构说明 |

---

## 附录：关键代码参考

### 使用 ResourceLoader 播放

```objc
// XCMusicPlayerModel.m - playWithURL:songId:

// 转换为自定义 scheme URL
XCResourceLoaderManager *resourceLoader = [XCResourceLoaderManager sharedInstance];
NSURL *streamingURL = [resourceLoader streamingURLFromOriginalURL:url songId:songId];

// 创建 AVURLAsset 并设置 resourceLoader
AVURLAsset *asset = [AVURLAsset URLAssetWithURL:streamingURL options:nil];
[asset.resourceLoader setDelegate:resourceLoader queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];

AVPlayerItem *playerItem = [AVPlayerItem playerItemWithAsset:asset];
```

### 数据流向

```
播放请求
    │
    ▼
AVPlayer → AVAssetResourceLoader → XCResourceLoaderManager
    │
    ├── L1 命中? → 直接返回缓存数据
    │
    ├── L3 命中? → 返回完整文件
    │
    └── 未命中 → 网络 Range 请求 → 写入 L1 → 返回数据
```

---

## 八、总结

本项目有两个可独立实施的部分：

1. **进度条拖动**（推荐先做）：实现用户交互，让用户能跳转到任意位置播放
2. **分段播放**（可选）：优化技术架构，实现真正的边下边播

已完成的缓存架构为这两个功能都打下了坚实基础。
