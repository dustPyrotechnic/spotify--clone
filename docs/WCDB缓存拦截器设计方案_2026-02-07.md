# WCDB 持久化缓存 + ResourceLoader 拦截器设计方案

> 设计日期：2026-02-07  
> 设计目标：实现支持 Seek 的分段持久化缓存  
> 兼容性：与现有代码完全兼容，渐进式升级

---

## 一、架构总览

### 核心流程对比

```
现有方案（内存缓存）:
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 用户点击 │───→│ 查内存  │───→│ 网络URL │
│ 播放    │    │ 未命中  │    │ 播放    │
└─────────┘    └─────────┘    └────┬────┘
                                    │
                                    ▼
                              后台下载整首
                              存入内存(NSCache)

问题: Seek时AVPlayer自己处理，与后台下载不共享数据


新方案（WCDB分段缓存+拦截器）:
┌─────────┐    ┌─────────┐    ┌─────────────────────────────────────┐
│ 用户点击 │───→│ 转换URL │───→│  custom://songId@originalHost/path  │
│ 播放    │    │ custom  │    │       触发ResourceLoader拦截         │
└─────────┘    └─────────┘    └──────────────────┬──────────────────┘
                                                  │
                         ┌────────────────────────┼────────────────────────┐
                         │ 拦截到请求                                   │
                         ▼                        │                        ▼
                  ┌──────────────┐               │               ┌──────────────┐
                  │ 查询WCDB缓存  │               │               │ 发起Range请求 │
                  │ 分段数据      │               │               │ 下载缺失部分  │
                  └──────┬───────┘               │               └──────┬───────┘
                         │ 命中/未命中           │                        │
                         ▼                      │                        ▼
                  ┌──────────────┐              │               ┌──────────────┐
                  │ 返回缓存数据  │              │               │ 边下边播      │
                  │ 给AVPlayer   │              │               │ 存入WCDB     │
                  └──────────────┘              │               └──────────────┘
                                                │
优势: Seek时优先查缓存，AVPlayer与缓存系统共享数据
```

---

## 二、核心设计思路

### 2.1 分层架构

| 层级 | 职责 | 关键组件 |
|------|------|----------|
| **应用层** | UI交互、播放控制 | XCMusicPlayerModel(无需修改) |
| **播放器层** | AVPlayer管理 | AVPlayerItem + ResourceLoaderDelegate |
| **缓存管理层** | 协调内存与磁盘缓存 | XCAudioCacheManager |
| **存储层** | 数据持久化 | WCDB (AudioMetadata + AudioSegment表) |

### 2.2 数据表设计

**AudioMetadata表** - 音频元数据
- 歌曲ID、原始URL、文件总大小、总时长
- 已缓存大小、缓存分段数、命中次数(LRU)
- 创建/更新时间

**AudioSegment表** - 分段数据
- 外键(歌曲ID)、起始/结束位置、音频数据(BLOB)
- 联合索引：songId + startOffset

**分段策略**: 256KB/段
- 足够大：减少数据库查询次数
- 足够小：避免浪费，匹配AVPlayer请求粒度

---

## 三、关键机制

### 3.1 ResourceLoader 拦截机制

```
AVPlayer请求数据
    │
    ▼
判断请求类型:
├── 内容信息请求(Content Information)
│   └── 返回文件总大小、MIME类型、支持Range
│
└── 数据请求(Data Request)
    ├── 解析请求范围(requestedOffset + requestedLength)
    ├── 查询WCDB该范围缓存状态
    │   ├── 完全命中 → 直接返回数据
    │   ├── 部分命中 → 返回缓存部分 + 下载缺失部分
    │   └── 未命中   → 发起Range请求下载
    └── 下载完成 → 存入WCDB + 返回给AVPlayer
```

### 3.2 缓存查询策略

| 缓存状态 | 处理方式 | 场景 |
|----------|----------|------|
| **完全命中** | 直接返回缓存数据 | 已播放过的片段 |
| **部分命中** | 返回已有数据 + 下载缺失部分 | 片段部分下载 |
| **未命中** | 发起Range请求下载 | 首次播放或Seek到新区域 |

### 3.3 间隙下载(Gap Downloading)

当用户Seek到未缓存区域时的下载策略:

1. **高优先级**: 立即下载当前播放点附近数据(256KB)，保证流畅播放
2. **中优先级**: 后台下载后续数据(1MB)，预加载即将播放的内容
3. **低优先级**: 可选回填间隙，完善缓存连续性

### 3.4 预加载机制

- **启动预加载**: 播放当前歌曲时，后台预加载前512KB(快速启动用)
- **下一首预加载**: 利用现有`playNextSong`机制，提前缓存下一首开头

---

## 四、Seek 支持实现

### 4.1 Seek 时的数据流

```
用户拖动进度条到 02:30
    │
    ▼
AVPlayer计算对应文件位置(~2.4MB)
    │
    ▼
ResourceLoader拦截请求(range=2400000-2560000)
    │
    ▼
查询WCDB:
    ├── 已缓存 → 立即返回(<10ms磁盘读取)
    └── 未缓存 → Range请求下载 → 边下边播 → 存入WCDB

用户再次Seek到 02:30:
    └── ✅ 命中缓存，即时响应
```

### 4.2 与现有方案对比

| 场景 | 现有方案 | 新方案 |
|------|----------|--------|
| Seek第一次 | 延迟取决于网络 | 延迟取决于网络(未缓存) |
| Seek第二次 | 延迟取决于网络(需重新下载) | 即时响应(已缓存) |
| 离线播放 | 不支持 | 完整缓存后支持 |
| 缓存粒度 | 整首(20MB限制) | 分段(256KB)，更灵活 |

---

## 五、缓存管理策略

### 5.1 多级缓存架构

```
Level 1: 内存缓存 (NSCache)
         存储当前播放分段，最快访问
         
Level 2: WCDB磁盘缓存
         持久化存储，App重启不丢失
         支持随机访问(Range查询)
         
Level 3: 网络
         最终数据源
```

### 5.2 清理策略

**自动清理触发条件**:
- 总缓存超过500MB
- 单首歌曲30天未播放

**LRU策略**:
- 保留播放次数>5的歌曲(用户喜爱)
- 优先删除低频次、旧缓存

### 5.3 与现有缓存的关系

- **共存**: 现有`XCMusicMemoryCache`作为L1缓存保留
- **互补**: WCDB作为L2持久化缓存
- **渐进升级**: 通过配置开关切换，便于A/B测试

---

## 六、实施路线图

### Phase 1: 基础设施 (1-2周)
- WCDB集成与表定义
- `XCAudioCacheManager`基础CRUD实现
- 数据库性能基准测试

### Phase 2: ResourceLoader实现 (2-3周)
- URL转换与拦截逻辑
- Range请求处理
- 分段缓存与间隙下载
- 预加载机制

### Phase 3: 集成测试 (1周)
- 与现有播放器集成(分类扩展方式)
- Seek体验调优
- A/B测试对比

### Phase 4: 性能优化 (1周)
- 数据库索引优化
- 批量操作与事务
- 缓存清理策略

---

## 七、风险与应对

| 风险 | 应对措施 |
|------|----------|
| WCDB增加包体积(~2-3MB) | 可接受；或改用FMDB(1MB) |
| 数据库操作耗时 | 后台线程+批量操作+索引优化 |
| 服务器不支持Range | 回退到完整下载模式 |
| 与现有缓存冲突 | 渐进式升级，保留切换开关 |

---

## 八、总结

### 核心改进点

1. **持久化存储**: 音频数据保存在WCDB，App重启不丢失
2. **分段管理**: 256KB分段，支持精确的Range查询
3. **拦截共享**: ResourceLoader拦截AVPlayer请求，复用下载数据
4. **Seek优化**: 已缓存片段支持即时Seek响应

### 与现有代码的集成

- **零侵入**: 现有`XCMusicPlayerModel`无需修改
- **渐进升级**: 新增分类扩展`XCMusicPlayerModel(WCDBCache)`
- **开关控制**: `XCPlayerConfig.useWCDBCache`随时切换

---

> 文档版本：1.0 (精简版)  
> 设计日期：2026-02-07
